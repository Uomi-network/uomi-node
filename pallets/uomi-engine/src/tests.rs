use pallet_ipfs::types::Cid;
use pallet_ipfs::CidsStatus;
use crate::{
    mock::*, Event, Inputs, MaxDataSize, OpocErrors, NodesOutputs, NodesVersions, OpocTimeouts, NodesWorks, OpocAssignment, OpocBlacklist, OpocLevel, Outputs,
    types::{ BlockNumber, Data, Address, NftId, RequestId },
    consts::{MAX_REQUEST_RETRIES}
};
use sp_std::vec;
use env_logger::Builder;
use frame_support::{
    assert_ok,
    traits::{Currency, OffchainWorker, OnFinalize, OnInitialize},
    BoundedVec,
};
use log::LevelFilter;
use sp_core::{
    sr25519::Public,
    H160, U256,
};
use sp_keystore::{
    testing::MemoryKeystore,
    Keystore, KeystoreExt,
};
use sp_runtime::{
    offchain::{testing::TestOffchainExt, OffchainDbExt, OffchainWorkerExt},
    traits::Dispatchable,
    Perbill,
};
use std::{
    io::Write,
    sync::{Arc, Mutex},
};
use sp_core::offchain::testing::TestTransactionPoolExt;
use sp_core::offchain::TransactionPoolExt;
use sp_std::collections::btree_map::BTreeMap;
use serial_test::serial;

type AccountId = Public;

// This is a sample test just to show how to write tests in Rust.
#[test]
fn test_sample() {
    fn ok() -> Result<(), &'static str> {
        Ok(())
    }

    assert_ok!(ok());
}

// ðŸš€ TEST FUNCTION run_request
// The function run_request is used to run a request in the uomi-engine module.
// It accept:
// - request_id: a incremental number to identify the request (generated by the smart contract)
// - address: the address of the user who made the request
// - nft_id: the id of the NFT associated with the request
// - input_data: the input data for the request
// - input_file_cid: the CID of the input file for the request
// - min_validators: the minimum number of validators required for the request
// - min_blocks: the minimum number of blocks required for the request
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// request_id is 0
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the request_id must be greater than 0.
#[test]
fn test_run_request_case_1() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 0.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());
        
        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Request ID must be greater than 0."));
    });
}

// CASE 2:
// address is 0x000...000
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the address is invalid.
#[test]
fn test_run_request_case_2() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0x00);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Address must not be zero."));
    });
}

// CASE 3:
// nft_id is 0
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the nft_id is invalid.
#[test]
fn test_run_request_case_3() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 0.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("NFT ID must be greater than 0."));
    });
}

// CASE 4:
// request_id is already used
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the request_id is already used.
#[test]
fn test_run_request_case_4() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        // First call to run_request should succeed
        let result1 = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result1.is_ok());

        // Second call to run_request with the same request_id should fail
        let result2 = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result2.is_err());

        let error = result2.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Request ID already exists."));
    });
}

// CASE 5:
// input_data size exceeds MaxDataSize
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the input_data size exceeds the maximum allowed size.
#[test]
fn test_run_request_case_5() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![0u8; (MaxDataSize::get() as usize) + 1]; // Exceeds MaxDataSize
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Input data too large."));
    });
}

// CASE 6:
// all inputs are valid
// EXPECTED âœ…:
// - The function should succeed and store the request correctly in the Inputs storage map.
#[test]
fn test_run_request_case_6() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_ok());

        // Verify storage
        let storage_input = Inputs::<Test>::get(request_id);
        let (si_block_number, si_address, si_nft_id, si_nft_required_consensus, si_nft_execution_max_time, si_nft_file_cid, si_input_data, si_input_file_cid) = storage_input;
        assert_eq!(si_block_number, System::block_number().into());
        assert_eq!(si_address, address);
        assert_eq!(si_nft_id, nft_id);
        assert_eq!(si_nft_required_consensus, min_validators);
        assert_eq!(si_nft_execution_max_time, min_blocks);
        assert_eq!(si_nft_file_cid, Cid::new());
        assert_eq!(si_input_data, input_data);
        assert_eq!(si_input_file_cid, input_file_cid);

        // Verify event
        let events = System::events();
        let events = events.iter().collect::<Vec<_>>();
        assert!(events.iter().any(|record| {
            matches!(
                record.event,
                RuntimeEvent::TestingPallet(Event::RequestAccepted { 
                    request_id: req_id,
                    address: addr,
                    nft_id: nft,
                }) if req_id == request_id && addr == address && nft == nft_id
            )
        }));
    });
}

// ðŸš€ TEST FUNCTIONALITY offchain_worker semaphore
// The offchain worker semaphore is used to manage the concurrency of the offchain worker executions.
// It should accept max 5 concurrent executions.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check semaphore allows max 5 concurrent executions
// EXPECTED âœ…:
// the semaphore should allow max 5 concurrent executions and block the 6th execution
#[test]
#[serial]
fn test_offchain_worker_semaphore_case_1() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        const LIMIT: u32 = 5;

        // Emulate workers acquiring slots up to the limit of LIMIT
        for i in 1..=LIMIT {
            assert!(TestingPallet::test_semaphore_try_to_add(&U256::from(i)));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Sixth acquire should fail because max = LIMIT
        assert!(!TestingPallet::test_semaphore_try_to_add(&U256::from(LIMIT + 1)));
        assert_eq!(TestingPallet::test_semaphore_counter(), LIMIT);

        // Release one slot and ensure counter decreases to LIMIT - 1
        TestingPallet::test_semaphore_remove(&U256::from(1));
        assert_eq!(TestingPallet::test_semaphore_counter(), LIMIT - 1);

        // Release all remaining slots and ensure counter returns to 0
        for i in (0..(LIMIT - 1)).rev() {
            TestingPallet::test_semaphore_remove(&U256::from(i + 2));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Now we should be able to acquire again up to the limit
        for i in 1..=LIMIT {
            assert!(TestingPallet::test_semaphore_try_to_add(&U256::from(i)));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Finally we release all slots
        // NOTE: Important to run other tests in sequence
        for i in (0..LIMIT).rev() {
            TestingPallet::test_semaphore_remove(&U256::from(i + 1));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }
    });
}

// ðŸš€ TEST FUNCTION offchain_worker
// The function offchain_worker is used by the offchain worker is executed offchain by a node.
// It do some check about the validator status and than call the offchain_run function to process the requests.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check node updates its version in NodesVersions storage
// EXPECTED âœ…:
// the node should update its version with a transaction in the pool to update the NodesVersions storage.
#[test]
#[serial]
fn test_offchain_worker_case_1() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 1);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 2:
// check semaphore is unlocked correctly after the offchain worker execution
// EXPECTED âœ…:
// the semaphore is correctly managed before and after the offchain worker execution
// after the offchain worker execution the semaphore must be 0 (unlocked)
#[test]
#[serial]
fn test_offchain_worker_case_2() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Be sure semaphore status and be sure is free before the execution of the offchain worker
        let semaphore = TestingPallet::test_semaphore_counter();
        assert_eq!(semaphore, 0u32); // No active offchain workers

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Read semaphore status and be sure is free after the execution of the offchain worker
        let semaphore = TestingPallet::test_semaphore_counter();
        assert_eq!(semaphore, 0u32);
    });
}

// CASE 3:
// check an execution fail caused by an invalid input data
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_3() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(1312); // Agent 1312 is the famous uomi whitepaper chat agent
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 4:
// check an execution fail caused by an infinite agent loop
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_4() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(1); // Agent 1 is a simple agent that run an infinite loop
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 5:
// check a successful execution of a request
// EXPECTED âœ…:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with the output data for the request
#[test]
#[serial]
fn test_offchain_worker_case_5() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(0); // Agent 0 is a simple agent that return correctly the input data inverted
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 6:
// check an execution fail caused by the nft_id is not found
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_6() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(9999); // Agent 9999 is not present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// ðŸš€ TEST FUNCTION offchain_run_wasm
// The function offchain_run_wasm is used by the offchain worker to execute the wasm associated with a nft_id.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check a successful execution of a wasm agent
// EXPECTED âœ…:
// the function should return the correct output data
#[test]
fn test_offchain_run_wasm_case_1() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent0.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is input_data reversed
        let input_data_reversed = input_data.iter().rev().cloned().collect::<Vec<u8>>();
        assert_eq!(result.unwrap(), input_data_reversed);
    });
}

// CASE 2:
// check an execution fail caused by an expiration_block_number before current block number
// EXPECTED ðŸš¨:
// the function should return an error indicating that the expiration_block_number is invalid
#[test]
fn test_offchain_run_wasm_case_2() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent0.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() - 1);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_err());
    });
}

// CASE 3:
// check an execution fail caused by a wasm with an infinite loop
// EXPECTED ðŸš¨:
// the function should return an error indicating that the execution timed out
#[test]
fn test_offchain_run_wasm_case_3() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent1.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_err());
    });
}

// CASE 4:
// check a successful execution of a wasm agent that uses the call_ai function to run a local model
// EXPECTED âœ…:
// the function should return the correct output data from the local model (in test it is the input data reversed)
#[test]
fn test_offchain_run_wasm_case_4() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent2.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is input_data reversed
        let input_data_reversed = input_data.iter().rev().cloned().collect::<Vec<u8>>();
        assert_eq!(result.unwrap(), input_data_reversed);
    });
}

// CASE 5:
// check a successful execution of a wasm agent that uses the get_cid_file function to read the input file from its cid
// EXPECTED âœ…:
// the function should return a success (NOTE: should be improved to check the actual output data)
#[test]
fn test_offchain_run_wasm_case_5() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent3.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());
    });
}

// CASE 6:
// check a successful execution of a wasm agent that uses the get_request_sender function to read the address of the request sender
// EXPECTED âœ…:
// the function should return the correct output data from the local model (in test it is the address readed with the function)
#[test]
fn test_offchain_run_wasm_case_6() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent4.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is address as bytes
        let address_as_vec: BoundedVec::<u8, MaxDataSize> = address.as_ref().to_vec().try_into().unwrap_or_else(|_| BoundedVec::<u8, MaxDataSize>::default());
        assert_eq!(result.unwrap(), address_as_vec);
    });
}

// ðŸš€ TEST FUNCTIONALITY opoc
// The opoc is executed on the on_finalize hook and to manage the requests assignment and outputs.
// --------------------------------------------------------------------------------------------------------------

// CASE 1: OPOC LEVEL -1
// check opoc execution without any requests
// EXPECTED:
// the function should complete without errors even if there are no requests to process
// the storages should not have any changes
#[test]
fn test_opoc_case_1() {
    make_logger();

    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment and NodesWorks storages are empty
        assert!(OpocAssignment::<Test>::iter().next().is_none());
        assert!(NodesWorks::<Test>::iter().next().is_none());
    });
}

// CASE 2: OPOC LEVEL -1
// check opoc execution with a single request requiring a single execution and a single validator available
// EXPECTED:
// the function should assign the request to the validator
#[test]
fn test_opoc_case_2() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the request assigned to the validator
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);

        // Check NodesWorks storage has the entry for the validator and request
        let nodes_works_number = NodesWorks::<Test>::get(validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
    });
}

// CASE 3: OPOC LEVEL -1
// check opoc execution with a single request requiring a single execution but no validators available
// EXPECTED:
// the function should not assign the request to any validator
#[test]
fn test_opoc_case_3() {
    make_logger();

    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has no assignments
        let opoc_assignment = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignment.len(), 0);
        
        // Check NodesWorks storage has no entries
        let nodes_works_number = NodesWorks::<Test>::iter().collect::<Vec<_>>();
        assert_eq!(nodes_works_number.len(), 0);
    });
}

// CASE 4: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator has not completed the work yet
// EXPECTED:
// the function should not change anything as the validator has not completed the work yet
#[test]
fn test_opoc_case_4() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the same assignment
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);
        // Check NodesWorks storage has the same entry for the validator and request
        let nodes_works_number = NodesWorks::<Test>::get(validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
    });
}

// CASE 5: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator is in timeout to complete the work and there is another validator available
// EXPECTED:
// the function should reassign the request to another available validator different from the timed-out one
#[test]
fn test_opoc_case_5() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 2;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();
        let another_validator = validators[1].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the new assignment
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, another_validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);
        // Check NodesWorks storage has the new entry for the another_validator and request
        let nodes_works_number = NodesWorks::<Test>::get(another_validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
        // Check the old assignment is removed
        assert!(!OpocAssignment::<Test>::contains_key(request_id, validator.clone()));
        assert!(!NodesWorks::<Test>::contains_key(validator.clone(), request_id));
        // Check the opoc timeouts has a record of the timeout
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, true);
        // Check the opoc blacklist has a record of the timeout error
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, true);
    });
}

// CASE 6: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator is in timeout to complete the work and there is no other validator available
// EXPECTED:
// the function should complete the request with a error
#[test]
fn test_opoc_case_6() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the old assignment is removed
        assert!(!OpocAssignment::<Test>::contains_key(request_id, validator.clone()));
        assert!(!NodesWorks::<Test>::contains_key(validator.clone(), request_id));
        // Check the opoc blacklist has a record of the timeout error
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, true);
        // Check the opoc timeouts has not a record of the timeout (it should be reset)
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, false);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
    });
}

// CASE 7: OPOC LEVEL 0
// check opoc execution with a single request already assigned to MAX_REQUEST_RETRIES validators at level 0 and all validators are in timeout
// EXPECTED:
// the function should complete the request with a error
#[test]
fn test_opoc_case_7() {
  make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = MAX_REQUEST_RETRIES + 1; // create MAX_REQUEST_RETRIES + 1 validators to have enough for timeouts
        let validators = create_validators(num_validators, stake);

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate timeouts for MAX_REQUEST_RETRIES - 1 validators by storing them in OpocTimeouts and OpocBlacklist
        for i in 1..MAX_REQUEST_RETRIES {
            let validator = validators[i as usize].clone();
            OpocTimeouts::<Test>::insert(request_id, validator.clone(), true);
            OpocBlacklist::<Test>::insert(nft_id, validator.clone(), true);
        }
        // Assign the request to the last validator at level 0
        let last_validator = validators[0].clone();
        OpocAssignment::<Test>::insert(request_id, last_validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(last_validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);

        // Check all assignments are removed
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);

        // Check the opoc timeouts are reset
        let opoc_timeouts = OpocTimeouts::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_timeouts.len(), 0);

        // Check the opoc blacklist remains (it should not be reset)
        for i in 0..MAX_REQUEST_RETRIES {
            let validator = validators[i as usize].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
            assert_eq!(is_blacklisted, true);
        }
    });
}

// CASE 8: OPOC LEVEL 0
// check opoc execution with a single request (that not require consensus) already assigned to a validator at level 0 and the validator has completed the work successfully
// EXPECTED:
// the function should complete the request with the output from the validator
#[test]
fn test_opoc_case_8() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the OpocTimeouts has not a record of the timeout (it should be reset)
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, false);
        // Check the OpocBlacklist has not a record of the timeout (it should not be set)
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, false);
        // Check the Outputs storage has the output from the validator
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, validator_output);
        assert_eq!(total_executions, 1 as u32);
        assert_eq!(total_consensus, 1 as u32);
        assert_eq!(output_nft_id, nft_id);
    });
}

// CASE 9: OPOC LEVEL 0
// check opoc execution with a single request (that require consensus of 3) already assigned to a validator at level 0 and the validator has completed the work successfully
// EXPECTED:
// the function should keep the request open waiting and assign it to other 2 validators to run the opoc level 1
#[test]
fn test_opoc_case_9() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has one assignment for each required consensus
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), nft_required_consensus.as_usize());
        // Check the OpocAssignment has the correct assignment for the first validator at level 0
        let opoc_assignment_0 = OpocAssignment::<Test>::get(request_id, validator.clone());
        assert_eq!(opoc_assignment_0.1, OpocLevel::Level0);
        // Check the OpocAssignment has the correct assignments for the new validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, validator_i.clone());
            assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
            assert_eq!(level, OpocLevel::Level1);
        }
        // Check the NodesWorks storage has one entry for each validator of opoc level 1
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), nft_required_consensus.as_usize() - 1);
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let nodes_works_entry = NodesWorks::<Test>::get(validator_i.clone(), request_id);
            assert_eq!(nodes_works_entry, true);
        }
    });
}

// CASE 10: OPOC LEVEL 0
// check opoc execution with a single request (that require consensus of 3) already assigned to a validator at level 0 and the validator has completed the work successfully but there are not enough other validators available to reach consensus
// EXPECTED:
// the function should complete the request with an error
#[test]
fn test_opoc_case_10() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the old assignment is removed
        assert!(!OpocAssignment::<Test>::contains_key(request_id, validator.clone()));
        assert!(!NodesWorks::<Test>::contains_key(validator.clone(), request_id));
        // Check the opoc blacklist has not a record of the timeout (it should not be set)
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, false);
        // Check the opoc timeouts has not a record of the timeout (it should be reset)
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, false);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
    });
}

// CASE 11: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and all validators have not completed the work yet
// EXPECTED:
// the function should not change anything as the validators have not completed the work yet
#[test]
fn test_opoc_case_11() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) - 1); // move block number forward but not enough to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has one entry for each required consensus
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), nft_required_consensus.as_usize());
        // Check the NodesWorks storage has one entry for each validator of opoc level 1
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), nft_required_consensus.as_usize() - 1);
        // Check the Outputs storage has no output for the request yet
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check OpocTimeouts storage has no entries for validators
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
        // Check OpocBlacklist storage has no entries for validators
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
    });
}

// CASE 12: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and one validator has completed the work successfully, the other is still working
// EXPECTED:
// the function should not change anything as the validators have not completed the work yet
#[test]
fn test_opoc_case_12() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for one validator at level 1
        let validator_1 = validators[1].clone();
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) - 1); // move block number forward but not enough to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has one entry for each required consensus
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), nft_required_consensus.as_usize());
        // Check the NodesWorks storage has one entry for each validator of opoc level 1
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), nft_required_consensus.as_usize() - 1);
        // Check the Outputs storage has no output for the request yet
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check OpocTimeouts storage has no entries for validators
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
        // Check OpocBlacklist storage has no entries for validators
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
    });
}

// CASE 13: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and one validator has completed the work successfully, the other is in timeout, there are other validators available to assign the work
// EXPECTED:
// the function should assign the timeout validator work to another available validator at level 1
#[test]
fn test_opoc_case_13() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 4;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for one validator at level 1
        let validator_1 = validators[1].clone();
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); 
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has one entry for each required consensus
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), nft_required_consensus.as_usize());
        // Check the NodesWorks storage has one entry for each validator of opoc level 1
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), nft_required_consensus.as_usize() - 1);
        // Check the Outputs storage has no output for the request yet
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check OpocTimeouts storage has one entry for the timeout validator
        let timeout_validator = validators[2].clone();
        let has_timeout = OpocTimeouts::<Test>::get(request_id, timeout_validator.clone());
        assert_eq!(has_timeout, true);
        // Check OpocBlacklist storage has one entry for the timeout validator
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, timeout_validator.clone());
        assert_eq!(is_blacklisted, true);
        // Check OpocAssignment has assigned the work to another available validator at level 1
        let new_validator = validators[3].clone();
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, new_validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level1);
        // Check NodesWorks has an entry for the new validator
        let nodes_works_entry = NodesWorks::<Test>::get(new_validator.clone(), request_id);
        assert_eq!(nodes_works_entry, true);
        // Check OpocAssignment has removed the entry for the timeout validator
        assert!(!OpocAssignment::<Test>::contains_key(request_id, timeout_validator.clone()));
        // Check NodesWorks has removed the entry for the timeout validator
        assert!(!NodesWorks::<Test>::contains_key(timeout_validator.clone(), request_id));
    });
}

// CASE 14: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and one validator has completed the work successfully, the other is in timeout, there are no other validators available to assign the work
// EXPECTED:
// the function should complete the request with an error, no validators should have the timeout recorded
#[test]
fn test_opoc_case_14() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for one validator at level 1
        let validator_1 = validators[1].clone();
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check the opoc blacklist has one entry for the timeout validator
        let timeout_validator = validators[2].clone();
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, timeout_validator.clone());
        assert_eq!(is_blacklisted, true);
        // Check other validators are not blacklisted
        for i in 0..nft_required_consensus.as_usize() -1 {
            let validator_i = validators[i].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
        // Check all validators do not have timeouts
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
    });
}

// CASE 15: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and one validator has completed the work successfully, the other is in timeout, we have reached the MAX_REQUEST_RETRIES for the request
// EXPECTED:
// the function should complete the request with an error, no validators should have the timeout recorded
#[test]
fn test_opoc_case_15() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 7;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for one validator at level 1
        let validator_1 = validators[1].clone();
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output.clone());

        // Simulate that the request has already reached the MAX_REQUEST_RETRIES - 1
        for i in 0..MAX_REQUEST_RETRIES - 1 {
            let validator_i = validators[3 + i as usize].clone();
            OpocTimeouts::<Test>::insert(request_id, validator_i.clone(), true);
            OpocBlacklist::<Test>::insert(nft_id, validator_i.clone(), true);
        }

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); 
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check the opoc blacklist has entries for all validators except the first two (the one at level 0 and the one that completed the work at level 1)
        for i in 2..num_validators {
            let validator_i = validators[i as usize].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, true);
        }
        for i in 0..2 {
            let validator_i = validators[i as usize].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
        // Check all validators do not have timeouts
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
    });
}

// CASE 16: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and both validators has completed the work successfully with the same output
// EXPECTED:
// the function should complete the request successfully
#[test]
fn test_opoc_case_16() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1 and complete their work
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
            NodesOutputs::<Test>::insert(request_id, validator_i.clone(), validator_output.clone());
        }

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the Outputs storage has a correct output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, validator_output.clone());
        assert_eq!(total_executions, nft_required_consensus.as_u32());
        assert_eq!(total_consensus, nft_required_consensus.as_u32());
        assert_eq!(output_nft_id, nft_id);
        // Check all validators do not have timeouts
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
        // Check all validators are not blacklisted
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
    });
}

// CASE 17: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and both validators has completed the work but with different outputs and there are other validators available to assign the work
// EXPECTED:
// the function should move to OPOC LEVEL 2 by assigning the work to 2/3 of other validators that have not already worked on the request
#[test]
fn test_opoc_case_17() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 15;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1 and complete their work
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for both validators at level 1 with different outputs
        let validator_1 = validators[1].clone();
        let validator_2 = validators[2].clone();
        let validator_output_1 = BoundedVec::try_from(vec![8, 9, 7]).expect("Vector exceeds the bound");
        let validator_output_2 = BoundedVec::try_from(vec![7, 8, 9]).expect("Vector exceeds the bound");
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output_1.clone());
        NodesOutputs::<Test>::insert(request_id, validator_2.clone(), validator_output_2.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Calculate number of validators to assign at level 2
        let number_of_validators = num_validators as u32 - nft_required_consensus.as_u32();
        let num_level_2_validators = (number_of_validators * 2 / 3) + 1;
        // Check the OpocAssignment storage has assignments for level 0 + level 1 + level 2 validators
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), (nft_required_consensus.as_usize() + num_level_2_validators as usize));
        // Check that NodesWorks has entries for level 2 validators
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), num_level_2_validators as usize);
        // Check the Outputs storage has no output for the request yet
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
    });
}

// CASE 18: OPOC LEVEL 1
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and assigned to 2 validators at level 1 and both validators has completed the work but with different outputs and there are not other validators available to assign the work
// EXPECTED:
// the function should complete the request with an error, no validators should have the timeout recorded
#[test]
fn test_opoc_case_18() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 3;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1 and complete their work
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for both validators at level 1 with different outputs
        let validator_1 = validators[1].clone();
        let validator_2 = validators[2].clone();
        let validator_output_1 = BoundedVec::try_from(vec![8, 9, 7]).expect("Vector exceeds the bound");
        let validator_output_2 = BoundedVec::try_from(vec![7, 8, 9]).expect("Vector exceeds the bound");
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output_1.clone());
        NodesOutputs::<Test>::insert(request_id, validator_2.clone(), validator_output_2.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
        // Check all validators do not have timeouts
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
        // Check all validators are not blacklisted
        for i in 0..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
    });
}

// CASE 19: OPOC LEVEL 2
// check opoc execution with a single request (that require consensus of 3) already completed by validator at level 0 and level 1 and assigned to validators at level 2 and all validators at level 2 gives the same output
// EXPECTED:
// the function should complete the request successfully with the majority output
#[test]
fn test_opoc_case_19() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 15;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 and mark it as completed
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesOutputs::<Test>::insert(request_id, validator.clone(), validator_output.clone());

        // Assign the request to the other validators at level 1 and complete their work
        for i in 1..nft_required_consensus.as_usize() {
            let validator_i = validators[i].clone();
            OpocAssignment::<Test>::insert(request_id, validator_i.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level1));
            NodesWorks::<Test>::insert(validator_i.clone(), request_id, true);
        }
        // Complete the work for both validators at level 1 with different outputs
        let validator_1 = validators[1].clone();
        let validator_2 = validators[2].clone();
        let validator_output_2 = BoundedVec::try_from(vec![7, 8, 9]).expect("Vector exceeds the bound");
        NodesOutputs::<Test>::insert(request_id, validator_1.clone(), validator_output.clone());
        NodesOutputs::<Test>::insert(request_id, validator_2.clone(), validator_output_2.clone());

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Complete the work for level 2 validators with the same output
        let mut validators_for_opoc_level_2 = Vec::new();
        for validator_i in validators.iter() {
            let (_, level) = OpocAssignment::<Test>::get(request_id, validator_i.clone());
            if level == OpocLevel::Level2 {
                validators_for_opoc_level_2.push(validator_i.clone());
                NodesOutputs::<Test>::insert(request_id, validator_i.clone(), validator_output.clone());
            }
        }

        // Run on_finalize again to process level 2 outputs
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 2);
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has no assignment for the request
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), 0);
        // Check the NodesWorks storage has no entry for the request
        let nodes_works_entries = NodesWorks::<Test>::iter().filter(|(_, req_id, _)| *req_id == request_id).collect::<Vec<_>>();
        assert_eq!(nodes_works_entries.len(), 0);
        // Check the Outputs storage has a correct output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, validator_output.clone());
        assert_eq!(total_executions, (nft_required_consensus.as_u32() + validators_for_opoc_level_2.len() as u32)); 
        assert_eq!(total_consensus, (nft_required_consensus.as_u32() + validators_for_opoc_level_2.len() as u32 - 1)); // -1 because one validator at level 1 had a different output
        assert_eq!(output_nft_id, nft_id);
        // Check all validators do not have timeouts
        for validator_i in validators.iter() {
            let has_timeout = OpocTimeouts::<Test>::get(request_id, validator_i.clone());
            assert_eq!(has_timeout, false);
        }
        // Check all validators are not blacklisted except the one at level 1 with different output
        let validator_level_1_different_output = validators[2].clone();
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_level_1_different_output.clone());
        assert_eq!(is_blacklisted, true);
        for validator_i in validators.iter() {
            if validator_i == &validator_level_1_different_output {
                continue;
            }
            let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator_i.clone());
            assert_eq!(is_blacklisted, false);
        }
        // Check all validators are not in OpocErrors except the one at level 1 with different output
        let opoc_errors = OpocErrors::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_errors.len(), 1);
        let opoc_error = OpocErrors::<Test>::get(request_id, validator_level_1_different_output.clone());
        assert_eq!(opoc_error, true);
    });
}

// CASE 20: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 for the second time, the first one timed out, the second one has completed the work successfully
// EXPECTED:
// the function should assign the request to validators for level 1 without penalizing the level 0 validator that has the timeout
#[test]
fn test_opoc_case_20() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 4;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0 who will make a timeout
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1);
        TestingPallet::on_finalize(System::block_number());

        // Now the validator should be in the blacklist and timeout and the request should be reassigned to the same validator at level 0 again
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, true);
        let has_timeout = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(has_timeout, true);

        // Found the new validator assignment at level 0
        let mut new_validator: AccountId = AccountId::default();
        for (assigned_validator, (_, level)) in OpocAssignment::<Test>::iter_prefix(request_id) {
            if level == OpocLevel::Level0 {
                new_validator = assigned_validator;
            }
        }
        assert!(new_validator != AccountId::default());
        assert!(new_validator != validator);

        // Complete the work for the new validator at level 0
        let validator_output = BoundedVec::try_from(vec![9, 8, 7]).expect("Vector exceeds the bound");
        NodesOutputs::<Test>::insert(request_id, new_validator.clone(), validator_output.clone());

        // Run on_finalize again to process the new level 0 output
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 2);
        TestingPallet::on_finalize(System::block_number());

        // Check the OpocAssignment storage has assignments for level 0 + level 1 validators
        let opoc_assignments = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignments.len(), nft_required_consensus.as_usize());

        // Be sure validator with timeout is not blacklisted for future assignments
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, false);
        // Be sure validator with timeout does not have timeout recorded for future assignments
        let has_timeout = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(has_timeout, false);
    });
}

// ðŸš€ TEST FUNCTION opoc_assignment_get_random_validators
// The opoc_assignment_get_random_validators function is used in OPOC assignment to select a random set of validators for processing a request.
// --------------------------------------------------------------------------------------------------------------

#[test]
fn test_opoc_assignment_get_random_validators_cases() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 100;
        let _validators = create_validators(num_validators, stake);

        let opoc_blacklist_operations = BTreeMap::<(AccountId, U256), bool>::new();
        let nodes_works_operations = BTreeMap::<AccountId, BTreeMap<U256, bool>>::new();

        // Request 100 validators, all available
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(100),
            false,
            vec![],
            &U256::from(1)
        ).unwrap();
        assert_eq!(validators.len(), 100);

        // Request 50 validators, all available
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(50),
            false,
            vec![],
            &U256::from(1)
        ).unwrap();
        assert_eq!(validators.len(), 50);

        // Request 1 validator, all available
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(1),
            false,
            vec![],
            &U256::from(1)
        ).unwrap();
        assert_eq!(validators.len(), 1);

        // Request 101 validators, not enough available
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(101),
            false,
            vec![],
            &U256::from(1)
        );
        assert_eq!(validators.is_err(), true);

        // Request 50 validators, exclude 50 validators
        let excluded_validators: Vec<AccountId> = (0..50).map(|i| AccountId::from_raw([i as u8; 32])).collect();
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(50),
            false,
            excluded_validators.clone(),
            &U256::from(1)
        ).unwrap();
        assert_eq!(validators.len(), 50);
        // be sure selected validators are not in the excluded_validators
        for validator in validators {
            assert_eq!(excluded_validators.contains(&validator), false);
        }

        // Request 50 validators, exclude 51 validators
        let excluded_validators: Vec<AccountId> = (0..51).map(|i| AccountId::from_raw([i as u8; 32])).collect();
        let validators = TestingPallet::opoc_assignment_get_random_validators(
            &opoc_blacklist_operations,
            &nodes_works_operations,
            U256::from(50),
            false,
            excluded_validators,
            &U256::from(1)
        );
        assert_eq!(validators.is_err(), true);
    });
}

// HELPERS
//////////////////////////////////////////////////////////////////////////////////

// This function initializes the logger for the tests.
// It makes possible to see the logs from the tested pallet directly in the console.
// USAGE: Run tests with `cargo test -- --show-output`
// This function also returns a counter that can be used to check how many logs were generated.
// Example: `let counter = make_logger();`
//          `assert_eq!(*counter.lock().unwrap(), 1);`
fn make_logger() -> Arc<Mutex<u16>> {
  let log_counter = Arc::new(Mutex::new(0_u16));
  let log_counter_ref = Arc::clone(&log_counter);
    
  Builder::new()
    .filter_level(LevelFilter::Info)
    .format(move |buf, record| {
      {
          let mut counter = log_counter_ref.lock().unwrap();
          *counter += 1;
      }
      writeln!(buf, "{} - {}", record.level(), record.args())
    })
    .is_test(true)
    .try_init()
    .ok();

  log_counter
}

fn setup_offchain_worker_environment() ->  (sp_io::TestExternalities, Public, scale_info::prelude::sync::Arc<parking_lot::RwLock<sp_core::offchain::testing::PoolState>>) {
    let mut ext = new_test_ext();

    let (offchain, _state) = TestOffchainExt::new();
    let (pool, state) = TestTransactionPoolExt::new();
    ext.register_extension(OffchainDbExt::new(offchain.clone()));
    ext.register_extension(OffchainWorkerExt::new(offchain));
    ext.register_extension(TransactionPoolExt::new(pool));

    let keystore = Arc::new(MemoryKeystore::new());
    keystore.sr25519_generate_new(crate::crypto::CRYPTO_KEY_TYPE, None).unwrap();
    ext.register_extension(KeystoreExt(keystore.clone()));
    let validator = keystore.sr25519_public_keys(crate::crypto::CRYPTO_KEY_TYPE).swap_remove(0);

    (ext, validator, state)
}

fn create_validators(num_validators: u32, stake: u128) -> Vec<AccountId> {
    let mut validators = Vec::new();
    
    for i in 0..num_validators {
        // Crea un account unico per ogni validator
        let seed = [i as u8; 32];
        let account_id = AccountId::from_raw(seed);
        
        // Assegna fondi all'account
        let _ = <Balances as Currency<AccountId>>::make_free_balance_be(
            &account_id,
            stake
        );

        // Bond i fondi
        assert_ok!(Staking::bond(
            RuntimeOrigin::signed(account_id.clone()),
            stake,
            pallet_staking::RewardDestination::Staked,
        ));

        // Dichiara l'intenzione di validare
        assert_ok!(Staking::validate(
            RuntimeOrigin::signed(account_id.clone()),
            pallet_staking::ValidatorPrefs {
                commission: Perbill::from_percent(0),
                blocked: false,
            }
        ));

        validators.push(account_id);
    }

    validators
}