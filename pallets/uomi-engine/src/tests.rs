use pallet_ipfs::types::Cid;
use pallet_ipfs::CidsStatus;
use crate::{
    mock::*, Event, Inputs, MaxDataSize, OpocErrors, NodesOutputs, NodesVersions, OpocTimeouts, NodesWorks, OpocAssignment, OpocBlacklist, OpocLevel, Outputs,
    types::{ BlockNumber, Data, Address, NftId, RequestId }
};
use sp_std::vec;
use env_logger::Builder;
use frame_support::{
    assert_ok,
    traits::{Currency, OffchainWorker, OnFinalize, OnInitialize},
    BoundedVec,
};
use log::LevelFilter;
use sp_core::{
    sr25519::Public,
    H160, U256,
};
use sp_keystore::{
    testing::MemoryKeystore,
    Keystore, KeystoreExt,
};
use sp_runtime::{
    offchain::{testing::TestOffchainExt, OffchainDbExt, OffchainWorkerExt},
    traits::Dispatchable,
    Perbill,
};
use std::{
    io::Write,
    sync::{Arc, Mutex},
};
use sp_core::offchain::testing::TestTransactionPoolExt;
use sp_core::offchain::TransactionPoolExt;
use sp_std::collections::btree_map::BTreeMap;
use serial_test::serial;

type AccountId = Public;

// This is a sample test just to show how to write tests in Rust.
#[test]
fn test_sample() {
    fn ok() -> Result<(), &'static str> {
        Ok(())
    }

    assert_ok!(ok());
}

// ðŸš€ TEST FUNCTION run_request
// The function run_request is used to run a request in the uomi-engine module.
// It accept:
// - request_id: a incremental number to identify the request (generated by the smart contract)
// - address: the address of the user who made the request
// - nft_id: the id of the NFT associated with the request
// - input_data: the input data for the request
// - input_file_cid: the CID of the input file for the request
// - min_validators: the minimum number of validators required for the request
// - min_blocks: the minimum number of blocks required for the request
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// request_id is 0
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the request_id must be greater than 0.
#[test]
fn test_run_request_case_1() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 0.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());
        
        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Request ID must be greater than 0."));
    });
}

// CASE 2:
// address is 0x000...000
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the address is invalid.
#[test]
fn test_run_request_case_2() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0x00);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Address must not be zero."));
    });
}

// CASE 3:
// nft_id is 0
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the nft_id is invalid.
#[test]
fn test_run_request_case_3() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 0.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("NFT ID must be greater than 0."));
    });
}

// CASE 4:
// request_id is already used
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the request_id is already used.
#[test]
fn test_run_request_case_4() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        // First call to run_request should succeed
        let result1 = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result1.is_ok());

        // Second call to run_request with the same request_id should fail
        let result2 = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result2.is_err());

        let error = result2.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Request ID already exists."));
    });
}

// CASE 5:
// input_data size exceeds MaxDataSize
// EXPECTED ðŸš¨:
// - The function should return an error indicating that the input_data size exceeds the maximum allowed size.
#[test]
fn test_run_request_case_5() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![0u8; (MaxDataSize::get() as usize) + 1]; // Exceeds MaxDataSize
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_err());

        let error = result.err().unwrap();
        assert_eq!(error, sp_runtime::DispatchError::Other("Input data too large."));
    });
}

// CASE 6:
// all inputs are valid
// EXPECTED âœ…:
// - The function should succeed and store the request correctly in the Inputs storage map.
#[test]
fn test_run_request_case_6() {
    make_logger();
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Inputs
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = 1.into();
        let input_data: Vec<u8> = vec![1, 2, 3];
        let input_file_cid: Vec<u8> = vec![1, 2, 3];
        let min_validators: U256 = U256::from(3);
        let min_blocks: U256 = U256::from(10);

        let result = TestingPallet::run_request(request_id, address, nft_id.clone(), input_data.clone(), input_file_cid.clone(), min_validators, min_blocks);
        assert!(result.is_ok());

        // Verify storage
        let storage_input = Inputs::<Test>::get(request_id);
        let (si_block_number, si_address, si_nft_id, si_nft_required_consensus, si_nft_execution_max_time, si_nft_file_cid, si_input_data, si_input_file_cid) = storage_input;
        assert_eq!(si_block_number, System::block_number().into());
        assert_eq!(si_address, address);
        assert_eq!(si_nft_id, nft_id);
        assert_eq!(si_nft_required_consensus, min_validators);
        assert_eq!(si_nft_execution_max_time, min_blocks);
        assert_eq!(si_nft_file_cid, Cid::new());
        assert_eq!(si_input_data, input_data);
        assert_eq!(si_input_file_cid, input_file_cid);

        // Verify event
        let events = System::events();
        let events = events.iter().collect::<Vec<_>>();
        assert!(events.iter().any(|record| {
            matches!(
                record.event,
                RuntimeEvent::TestingPallet(Event::RequestAccepted { 
                    request_id: req_id,
                    address: addr,
                    nft_id: nft,
                }) if req_id == request_id && addr == address && nft == nft_id
            )
        }));
    });
}

// ðŸš€ TEST FUNCTIONALITY offchain_worker semaphore
// The offchain worker semaphore is used to manage the concurrency of the offchain worker executions.
// It should accept max 5 concurrent executions.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check semaphore allows max 5 concurrent executions
// EXPECTED âœ…:
// the semaphore should allow max 5 concurrent executions and block the 6th execution
#[test]
#[serial]
fn test_offchain_worker_semaphore_case_1() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        const LIMIT: u32 = 5;

        // Emulate workers acquiring slots up to the limit of LIMIT
        for i in 1..=LIMIT {
            assert!(TestingPallet::test_semaphore_try_to_add(&U256::from(i)));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Sixth acquire should fail because max = LIMIT
        assert!(!TestingPallet::test_semaphore_try_to_add(&U256::from(LIMIT + 1)));
        assert_eq!(TestingPallet::test_semaphore_counter(), LIMIT);

        // Release one slot and ensure counter decreases to LIMIT - 1
        TestingPallet::test_semaphore_remove(&U256::from(1));
        assert_eq!(TestingPallet::test_semaphore_counter(), LIMIT - 1);

        // Release all remaining slots and ensure counter returns to 0
        for i in (0..(LIMIT - 1)).rev() {
            TestingPallet::test_semaphore_remove(&U256::from(i + 2));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Now we should be able to acquire again up to the limit
        for i in 1..=LIMIT {
            assert!(TestingPallet::test_semaphore_try_to_add(&U256::from(i)));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }

        // Finally we release all slots
        // NOTE: Important to run other tests in sequence
        for i in (0..LIMIT).rev() {
            TestingPallet::test_semaphore_remove(&U256::from(i + 1));
            assert_eq!(TestingPallet::test_semaphore_counter(), i);
        }
    });
}

// ðŸš€ TEST FUNCTION offchain_worker
// The function offchain_worker is used by the offchain worker is executed offchain by a node.
// It do some check about the validator status and than call the offchain_run function to process the requests.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check node updates its version in NodesVersions storage
// EXPECTED âœ…:
// the node should update its version with a transaction in the pool to update the NodesVersions storage.
#[test]
#[serial]
fn test_offchain_worker_case_1() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 1);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 2:
// check semaphore is unlocked correctly after the offchain worker execution
// EXPECTED âœ…:
// the semaphore is correctly managed before and after the offchain worker execution
// after the offchain worker execution the semaphore must be 0 (unlocked)
#[test]
#[serial]
fn test_offchain_worker_case_2() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Be sure semaphore status and be sure is free before the execution of the offchain worker
        let semaphore = TestingPallet::test_semaphore_counter();
        assert_eq!(semaphore, 0u32); // No active offchain workers

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Read semaphore status and be sure is free after the execution of the offchain worker
        let semaphore = TestingPallet::test_semaphore_counter();
        assert_eq!(semaphore, 0u32);
    });
}

// CASE 3:
// check an execution fail caused by an invalid input data
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_3() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(1312); // Agent 1312 is the famous uomi whitepaper chat agent
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 4:
// check an execution fail caused by an infinite agent loop
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_4() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(1); // Agent 1 is a simple agent that run an infinite loop
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 5:
// check a successful execution of a request
// EXPECTED âœ…:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with the output data for the request
#[test]
#[serial]
fn test_offchain_worker_case_5() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(0); // Agent 0 is a simple agent that return correctly the input data inverted
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// CASE 6:
// check an execution fail caused by the nft_id is not found
// EXPECTED ðŸš¨:
// the offchain worker should create a transaction in the pool to update the NodesOutputs storage with an error for the request
#[test]
#[serial]
fn test_offchain_worker_case_6() {
    make_logger();
    let (mut ext, validator, state) = setup_offchain_worker_environment();

    ext.execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::from(9999); // Agent 9999 is not present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(3);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Simulate the request is assigned to the validator during opoc execution for opoc level 0
        OpocAssignment::<Test>::insert(
            request_id, // request_id
            validator.clone(), // validator
            (
                U256::from(System::block_number() + 1),
                OpocLevel::Level0
            ) // (expiration_block_number, opoc_level)
        );
        NodesWorks::<Test>::insert(
            validator.clone(),
            request_id,
            true
        );

        // Run the offchain worker
        TestingPallet::offchain_worker(System::block_number());

        // Verify transactions in the pool
        // the first transaction is the update of the NodeVersions storage by the node (to store its version)
        // the second transaction is the update of the NodeOutputs with the execution result (which should be an error)
        let state_read = state.read();
        assert_eq!(state_read.transactions.len(), 2);

        // NOTE: We should find a way to force the execution of the transactions and check the storage update
    });
}

// ðŸš€ TEST FUNCTION offchain_run_wasm
// The function offchain_run_wasm is used by the offchain worker to execute the wasm associated with a nft_id.
// --------------------------------------------------------------------------------------------------------------

// CASE 1:
// check a successful execution of a wasm agent
// EXPECTED âœ…:
// the function should return the correct output data
#[test]
fn test_offchain_run_wasm_case_1() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent0.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is input_data reversed
        let input_data_reversed = input_data.iter().rev().cloned().collect::<Vec<u8>>();
        assert_eq!(result.unwrap(), input_data_reversed);
    });
}

// CASE 2:
// check an execution fail caused by an expiration_block_number before current block number
// EXPECTED ðŸš¨:
// the function should return an error indicating that the expiration_block_number is invalid
#[test]
fn test_offchain_run_wasm_case_2() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent0.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() - 1);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_err());
    });
}

// CASE 3:
// check an execution fail caused by a wasm with an infinite loop
// EXPECTED ðŸš¨:
// the function should return an error indicating that the execution timed out
#[test]
fn test_offchain_run_wasm_case_3() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent1.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_err());
    });
}

// CASE 4:
// check a successful execution of a wasm agent that uses the call_ai function to run a local model
// EXPECTED âœ…:
// the function should return the correct output data from the local model (in test it is the input data reversed)
#[test]
fn test_offchain_run_wasm_case_4() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent2.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is input_data reversed
        let input_data_reversed = input_data.iter().rev().cloned().collect::<Vec<u8>>();
        assert_eq!(result.unwrap(), input_data_reversed);
    });
}

// CASE 5:
// check a successful execution of a wasm agent that uses the get_cid_file function to read the input file from its cid
// EXPECTED âœ…:
// the function should return a success (NOTE: should be improved to check the actual output data)
#[test]
fn test_offchain_run_wasm_case_5() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent3.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());
    });
}

// CASE 6:
// check a successful execution of a wasm agent that uses the get_request_sender function to read the address of the request sender
// EXPECTED âœ…:
// the function should return the correct output data from the local model (in test it is the address readed with the function)
#[test]
fn test_offchain_run_wasm_case_6() {
    make_logger();
    
    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        let wasm = include_bytes!("./test_agents/agent4.wasm").to_vec();
        let input_data = BoundedVec::<u8, MaxDataSize>::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid = Cid::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let address = H160::repeat_byte(0xAA);
        let block_number = U256::from(System::block_number());
        let expiration_block_number = U256::from(System::block_number() + 10);
        let nft_required_consensus = U256::from(1);
        let nft_execution_max_time = U256::from(99);
        let request_id = U256::from(1);
        let result = TestingPallet::offchain_run_wasm(
            wasm.clone(),
            input_data.clone(),
            input_file_cid.clone(),
            address,
            block_number,
            expiration_block_number, 
            nft_required_consensus,
            nft_execution_max_time,
            request_id,
            OpocLevel::Level0
        );
        assert!(result.is_ok());

        // Be sure result is address as bytes
        let address_as_vec: BoundedVec::<u8, MaxDataSize> = address.as_ref().to_vec().try_into().unwrap_or_else(|_| BoundedVec::<u8, MaxDataSize>::default());
        assert_eq!(result.unwrap(), address_as_vec);
    });
}

// ðŸš€ TEST FUNCTIONALITY opoc
// The opoc is executed on the on_finalize hook and to manage the requests assignment and outputs.
// --------------------------------------------------------------------------------------------------------------

// CASE 1: OPOC LEVEL -1
// check opoc execution without any requests
// EXPECTED:
// the function should complete without errors even if there are no requests to process
// the storages should not have any changes
#[test]
fn test_opoc_case_1() {
    make_logger();

    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment and NodesWorks storages are empty
        assert!(OpocAssignment::<Test>::iter().next().is_none());
        assert!(NodesWorks::<Test>::iter().next().is_none());
    });
}

// CASE 2: OPOC LEVEL -1
// check opoc execution with a single request requiring a single execution and a single validator available
// EXPECTED:
// the function should assign the request to the validator
#[test]
fn test_opoc_case_2() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the request assigned to the validator
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);

        // Check NodesWorks storage has the entry for the validator and request
        let nodes_works_number = NodesWorks::<Test>::get(validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
    });
}

// CASE 3: OPOC LEVEL -1
// check opoc execution with a single request requiring a single execution but no validators available
// EXPECTED:
// the function should not assign the request to any validator
#[test]
fn test_opoc_case_3() {
    make_logger();

    new_test_ext().execute_with(|| {
        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has no assignments
        let opoc_assignment = OpocAssignment::<Test>::iter_prefix_values(request_id).collect::<Vec<_>>();
        assert_eq!(opoc_assignment.len(), 0);
        
        // Check NodesWorks storage has no entries
        let nodes_works_number = NodesWorks::<Test>::iter().collect::<Vec<_>>();
        assert_eq!(nodes_works_number.len(), 0);
    });
}

// CASE 4: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator has not completed the work yet
// EXPECTED:
// the function should not change anything as the validator has not completed the work yet
#[test]
fn test_opoc_case_4() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the same assignment
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);
        // Check NodesWorks storage has the same entry for the validator and request
        let nodes_works_number = NodesWorks::<Test>::get(validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
    });
}

// CASE 5: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator is in timeout to complete the work and there is another validator available
// EXPECTED:
// the function should reassign the request to another available validator different from the timed-out one
#[test]
fn test_opoc_case_5() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 2;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();
        let another_validator = validators[1].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check OpocAssignment storage has the new assignment
        let (expiration_block_number, level) = OpocAssignment::<Test>::get(request_id, another_validator.clone());
        assert_eq!(expiration_block_number, U256::from(System::block_number()) + nft_execution_max_time);
        assert_eq!(level, OpocLevel::Level0);
        // Check NodesWorks storage has the new entry for the another_validator and request
        let nodes_works_number = NodesWorks::<Test>::get(another_validator.clone(), request_id);
        assert_eq!(nodes_works_number, true);
        // Check the old assignment is removed
        assert!(!OpocAssignment::<Test>::contains_key(request_id, validator.clone()));
        assert!(!NodesWorks::<Test>::contains_key(validator.clone(), request_id));
        // Check the opoc timeouts has a record of the timeout
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, true);
        // Check the opoc blacklist has a record of the timeout error
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, true);
    });
}

// CASE 6: OPOC LEVEL 0
// check opoc execution with a single request already assigned to a validator at level 0 and the validator is in timeout to complete the work and there is no other validator available
// EXPECTED:
// the function should complete the request with a error
#[test]
fn test_opoc_case_6() {
    make_logger();

    new_test_ext().execute_with(|| {
        let stake = 10_000_000_000_000_000_000;
        let num_validators = 1;
        let validators = create_validators(num_validators, stake);
        let validator = validators[0].clone();

        System::set_block_number(1);

        // Create a sample request in Inputs storage
        let request_id: RequestId = 1.into();
        let address: Address = H160::repeat_byte(0xAA);
        let nft_id: NftId = U256::zero(); // Agent 0 is always present in tests
        let input_data = BoundedVec::try_from(vec![1, 2, 3]).expect("Vector exceeds the bound");
        let input_file_cid: Cid = Cid::default();
        let nft_required_consensus: U256 = U256::from(1);
        let nft_execution_max_time: U256 = U256::from(10);
        Inputs::<Test>::insert(request_id, (
            U256::from(System::block_number() - 1), // block_number SET IT TO CURRENT BLOCK NUMBER - 1 TO SIMULATE A OLD REQUEST
            address, // address
            nft_id, // nft_id
            nft_required_consensus, // nft_required_consensus
            nft_execution_max_time, // nft_execution_max_time
            Cid::default(), // nft_file_cid ONLY FOR TESTS WE FORCE ALWAYS DEFAULT AS nft_file_cid, WE USE nft_id TO LOAD THE TESTS AGENTS
            input_data, // input_data
            input_file_cid, // input_file_cid
        ));

        // Assign the request to the validator at level 0
        OpocAssignment::<Test>::insert(request_id, validator.clone(), (U256::from(System::block_number()) + nft_execution_max_time, OpocLevel::Level0));
        NodesWorks::<Test>::insert(validator.clone(), request_id, true);

        // Run on_finalize to trigger opoc on a new block number
        System::set_block_number(((U256::from(System::block_number()) + nft_execution_max_time).as_u64()) + 1); // move block number forward to simulate timeout
        TestingPallet::on_finalize(System::block_number());

        // Check the old assignment is removed
        assert!(!OpocAssignment::<Test>::contains_key(request_id, validator.clone()));
        assert!(!NodesWorks::<Test>::contains_key(validator.clone(), request_id));
        // Check the opoc blacklist has a record of the timeout error
        let is_blacklisted = OpocBlacklist::<Test>::get(nft_id, validator.clone());
        assert_eq!(is_blacklisted, true);
        // Check the opoc timeouts has not a record of the timeout (it should be reset)
        let timeouts = OpocTimeouts::<Test>::get(request_id, validator.clone());
        assert_eq!(timeouts, false);
        // Check the Outputs storage has an empty output for the request
        let (output_data, total_executions, total_consensus, output_nft_id) = Outputs::<Test>::get(request_id);
        assert_eq!(output_data, Data::default());
        assert_eq!(total_executions, 0 as u32);
        assert_eq!(total_consensus, 0 as u32);
        assert_eq!(output_nft_id, nft_id);
    });
}

// CASE 7: OPOC LEVEL 0
// check opoc execution with a single request already assigned to MAX_REQUEST_RETRIES validators at level 0 and all validators are in timeout
// EXPECTED:
// the function should complete the request with a error
#[test]
fn test_opoc_case_7() {
  // TODO...
}

// HELPERS
//////////////////////////////////////////////////////////////////////////////////

// This function initializes the logger for the tests.
// It makes possible to see the logs from the tested pallet directly in the console.
// USAGE: Run tests with `cargo test -- --show-output`
// This function also returns a counter that can be used to check how many logs were generated.
// Example: `let counter = make_logger();`
//          `assert_eq!(*counter.lock().unwrap(), 1);`
fn make_logger() -> Arc<Mutex<u16>> {
  let log_counter = Arc::new(Mutex::new(0_u16));
  let log_counter_ref = Arc::clone(&log_counter);
    
  Builder::new()
    .filter_level(LevelFilter::Info)
    .format(move |buf, record| {
      {
          let mut counter = log_counter_ref.lock().unwrap();
          *counter += 1;
      }
      writeln!(buf, "{} - {}", record.level(), record.args())
    })
    .is_test(true)
    .try_init()
    .ok();

  log_counter
}

fn setup_offchain_worker_environment() ->  (sp_io::TestExternalities, Public, scale_info::prelude::sync::Arc<parking_lot::RwLock<sp_core::offchain::testing::PoolState>>) {
    let mut ext = new_test_ext();

    let (offchain, _state) = TestOffchainExt::new();
    let (pool, state) = TestTransactionPoolExt::new();
    ext.register_extension(OffchainDbExt::new(offchain.clone()));
    ext.register_extension(OffchainWorkerExt::new(offchain));
    ext.register_extension(TransactionPoolExt::new(pool));

    let keystore = Arc::new(MemoryKeystore::new());
    keystore.sr25519_generate_new(crate::crypto::CRYPTO_KEY_TYPE, None).unwrap();
    ext.register_extension(KeystoreExt(keystore.clone()));
    let validator = keystore.sr25519_public_keys(crate::crypto::CRYPTO_KEY_TYPE).swap_remove(0);

    (ext, validator, state)
}

fn create_validators(num_validators: u32, stake: u128) -> Vec<AccountId> {
    let mut validators = Vec::new();
    
    for i in 0..num_validators {
        // Crea un account unico per ogni validator
        let seed = [i as u8; 32];
        let account_id = AccountId::from_raw(seed);
        
        // Assegna fondi all'account
        let _ = <Balances as Currency<AccountId>>::make_free_balance_be(
            &account_id,
            stake
        );

        // Bond i fondi
        assert_ok!(Staking::bond(
            RuntimeOrigin::signed(account_id.clone()),
            stake,
            pallet_staking::RewardDestination::Staked,
        ));

        // Dichiara l'intenzione di validare
        assert_ok!(Staking::validate(
            RuntimeOrigin::signed(account_id.clone()),
            pallet_staking::ValidatorPrefs {
                commission: Perbill::from_percent(0),
                blocked: false,
            }
        ));

        validators.push(account_id);
    }

    validators
}